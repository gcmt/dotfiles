diff -ura i3lock.orig/unlock_indicator.c i3lock.new/unlock_indicator.c
--- i3lock.orig/unlock_indicator.c	2018-10-12 17:02:29.543336354 +0200
+++ i3lock.new/unlock_indicator.c	2018-10-12 17:04:04.756669752 +0200
@@ -22,11 +22,6 @@
 #include "randr.h"
 #include "dpi.h"
 
-#define BUTTON_RADIUS 90
-#define BUTTON_SPACE (BUTTON_RADIUS + 5)
-#define BUTTON_CENTER (BUTTON_RADIUS + 5)
-#define BUTTON_DIAMETER (2 * BUTTON_SPACE)
-
 /*******************************************************************************
  * Variables defined in i3lock.c.
  ******************************************************************************/
@@ -73,6 +68,9 @@
  * Local variables.
  ******************************************************************************/
 
+/* Lock icon */
+cairo_surface_t *lock_image;
+
 /* Cache the screen’s visual, necessary for creating a Cairo context. */
 static xcb_visualtype_t *vistype;
 
@@ -87,24 +85,77 @@
  *
  */
 xcb_pixmap_t draw_image(uint32_t *resolution) {
+
     xcb_pixmap_t bg_pixmap = XCB_NONE;
     const double scaling_factor = get_dpi_value() / 96.0;
-    int button_diameter_physical = ceil(scaling_factor * BUTTON_DIAMETER);
-    DEBUG("scaling_factor is %.f, physical diameter is %d px\n",
-          scaling_factor, button_diameter_physical);
 
-    if (!vistype)
+    if (!vistype) {
         vistype = get_root_visual_type(screen);
+    }
+
     bg_pixmap = create_bg_pixmap(conn, screen, resolution, color);
-    /* Initialize cairo: Create one in-memory surface to render the unlock
-     * indicator on, create one XCB surface to actually draw (one or more,
-     * depending on the amount of screens) unlock indicators on. */
-    cairo_surface_t *output = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, button_diameter_physical, button_diameter_physical);
-    cairo_t *ctx = cairo_create(output);
 
     cairo_surface_t *xcb_output = cairo_xcb_surface_create(conn, bg_pixmap, vistype, resolution[0], resolution[1]);
     cairo_t *xcb_ctx = cairo_create(xcb_output);
 
+    const int top_margin = 300;
+    const int psw_top_margin = 60;
+    const int msg_top_margin = 60;
+
+    /* Password field */
+
+    const double psw_dots_radius = ceil(scaling_factor * 5);
+    const double psw_dots_spacing = ceil(scaling_factor * 8);
+
+    double psw_height = psw_dots_radius * 2;
+    double psw_width = 1;
+
+    if (input_position) {
+        psw_width = input_position * (psw_dots_radius * 2) + (input_position - 1) * psw_dots_spacing;
+    }
+
+    cairo_surface_t *psw_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, psw_width, psw_height);;
+    cairo_t *psw_ctx = cairo_create(psw_surface);
+
+    /* Auth state message */
+
+    const double msg_width = 400;
+    const double msg_height = 50;
+
+    cairo_surface_t *msg_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, msg_width, msg_height);
+    cairo_t *msg_ctx = cairo_create(msg_surface);
+
+    /* Lock icon */
+
+    const char *lock_path = "/usr/share/i3lock/resources/lock.png";
+    double lock_width = 35;
+    double lock_height = 0;
+    double lock_scaling = 1.0;
+
+    if (!lock_image) {
+        lock_image = cairo_image_surface_create_from_png(lock_path);
+    }
+
+    bool image_loaded = cairo_surface_status(lock_image) == CAIRO_STATUS_SUCCESS;
+
+    if (image_loaded) {
+        const double lock_image_width = cairo_image_surface_get_width(lock_image);
+        const double lock_image_height = cairo_image_surface_get_height(lock_image);
+        lock_scaling = lock_width / lock_image_width;
+        lock_height = floor(lock_image_height * lock_scaling);
+    }
+
+    cairo_surface_t *lock_surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, lock_width, lock_height);
+    cairo_t *lock_ctx = cairo_create(lock_surface);
+
+    if (image_loaded) {
+        cairo_scale(lock_ctx, lock_scaling, lock_scaling);
+        cairo_set_source_surface(lock_ctx, lock_image, 0, 0);
+        cairo_paint(lock_ctx);
+    }
+
+    /* Display background image */
+
     if (img) {
         if (!tile) {
             cairo_set_source_surface(xcb_ctx, img, 0, 0);
@@ -131,80 +182,24 @@
         cairo_fill(xcb_ctx);
     }
 
-    if (unlock_indicator &&
-        (unlock_state >= STATE_KEY_PRESSED || auth_state > STATE_AUTH_IDLE)) {
-        cairo_scale(ctx, scaling_factor, scaling_factor);
-        /* Draw a (centered) circle with transparent background. */
-        cairo_set_line_width(ctx, 10.0);
-        cairo_arc(ctx,
-                  BUTTON_CENTER /* x */,
-                  BUTTON_CENTER /* y */,
-                  BUTTON_RADIUS /* radius */,
-                  0 /* start */,
-                  2 * M_PI /* end */);
-
-        /* Use the appropriate color for the different PAM states
-         * (currently verifying, wrong password, or default) */
-        switch (auth_state) {
-            case STATE_AUTH_VERIFY:
-            case STATE_AUTH_LOCK:
-                cairo_set_source_rgba(ctx, 0, 114.0 / 255, 255.0 / 255, 0.75);
-                break;
-            case STATE_AUTH_WRONG:
-            case STATE_I3LOCK_LOCK_FAILED:
-                cairo_set_source_rgba(ctx, 250.0 / 255, 0, 0, 0.75);
-                break;
-            default:
-                if (unlock_state == STATE_NOTHING_TO_DELETE) {
-                    cairo_set_source_rgba(ctx, 250.0 / 255, 0, 0, 0.75);
-                    break;
-                }
-                cairo_set_source_rgba(ctx, 0, 0, 0, 0.75);
-                break;
-        }
-        cairo_fill_preserve(ctx);
+    if (unlock_indicator && (unlock_state >= STATE_KEY_PRESSED || auth_state > STATE_AUTH_IDLE)) {
 
-        switch (auth_state) {
-            case STATE_AUTH_VERIFY:
-            case STATE_AUTH_LOCK:
-                cairo_set_source_rgb(ctx, 51.0 / 255, 0, 250.0 / 255);
-                break;
-            case STATE_AUTH_WRONG:
-            case STATE_I3LOCK_LOCK_FAILED:
-                cairo_set_source_rgb(ctx, 125.0 / 255, 51.0 / 255, 0);
-                break;
-            case STATE_AUTH_IDLE:
-                if (unlock_state == STATE_NOTHING_TO_DELETE) {
-                    cairo_set_source_rgb(ctx, 125.0 / 255, 51.0 / 255, 0);
-                    break;
-                }
+        /* Print each password character as a dot */
 
-                cairo_set_source_rgb(ctx, 51.0 / 255, 125.0 / 255, 0);
-                break;
+        cairo_scale(psw_ctx, scaling_factor, scaling_factor);
+        cairo_set_source_rgba(psw_ctx, 255.0, 255.0, 255.0, 1);
+        for (int x = psw_dots_radius; x < psw_width; x += (psw_dots_radius*2 + psw_dots_spacing)) {
+            cairo_arc(psw_ctx, x, psw_height/2.0, psw_dots_radius, 0, 2*M_PI);
+            cairo_fill(psw_ctx);
         }
-        cairo_stroke(ctx);
-
-        /* Draw an inner seperator line. */
-        cairo_set_source_rgb(ctx, 0, 0, 0);
-        cairo_set_line_width(ctx, 2.0);
-        cairo_arc(ctx,
-                  BUTTON_CENTER /* x */,
-                  BUTTON_CENTER /* y */,
-                  BUTTON_RADIUS - 5 /* radius */,
-                  0,
-                  2 * M_PI);
-        cairo_stroke(ctx);
 
-        cairo_set_line_width(ctx, 10.0);
+        /* Display a text of the current PAM state */
 
-        /* Display a (centered) text of the current PAM state. */
         char *text = NULL;
-        /* We don't want to show more than a 3-digit number. */
-        char buf[4];
+        cairo_set_source_rgb(msg_ctx, 255.0, 255.0, 255.0);
+        cairo_select_font_face(msg_ctx, "Noto Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
+        cairo_set_font_size(msg_ctx, 14.0);
 
-        cairo_set_source_rgb(ctx, 0, 0, 0);
-        cairo_select_font_face(ctx, "sans-serif", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
-        cairo_set_font_size(ctx, 28.0);
         switch (auth_state) {
             case STATE_AUTH_VERIFY:
                 text = "verifying…";
@@ -213,7 +208,7 @@
                 text = "locking…";
                 break;
             case STATE_AUTH_WRONG:
-                text = "wrong!";
+                text = "wrong password!";
                 break;
             case STATE_I3LOCK_LOCK_FAILED:
                 text = "lock failed!";
@@ -222,113 +217,107 @@
                 if (unlock_state == STATE_NOTHING_TO_DELETE) {
                     text = "no input";
                 }
-                if (show_failed_attempts && failed_attempts > 0) {
-                    if (failed_attempts > 999) {
-                        text = "> 999";
-                    } else {
-                        snprintf(buf, sizeof(buf), "%d", failed_attempts);
-                        text = buf;
-                    }
-                    cairo_set_source_rgb(ctx, 1, 0, 0);
-                    cairo_set_font_size(ctx, 32.0);
-                }
                 break;
         }
 
         if (text) {
+
             cairo_text_extents_t extents;
             double x, y;
 
-            cairo_text_extents(ctx, text, &extents);
-            x = BUTTON_CENTER - ((extents.width / 2) + extents.x_bearing);
-            y = BUTTON_CENTER - ((extents.height / 2) + extents.y_bearing);
-
-            cairo_move_to(ctx, x, y);
-            cairo_show_text(ctx, text);
-            cairo_close_path(ctx);
+            cairo_text_extents(msg_ctx, text, &extents);
+            x = msg_width/2 - extents.width/2;
+            y = extents.height/2 - extents.y_bearing;
+
+            cairo_move_to(msg_ctx, x, y);
+            cairo_show_text(msg_ctx, text);
+            cairo_close_path(msg_ctx);
+
         }
 
         if (auth_state == STATE_AUTH_WRONG && (modifier_string != NULL)) {
+
             cairo_text_extents_t extents;
             double x, y;
 
-            cairo_set_font_size(ctx, 14.0);
+            cairo_set_font_size(msg_ctx, 14.0);
 
-            cairo_text_extents(ctx, modifier_string, &extents);
-            x = BUTTON_CENTER - ((extents.width / 2) + extents.x_bearing);
-            y = BUTTON_CENTER - ((extents.height / 2) + extents.y_bearing) + 28.0;
-
-            cairo_move_to(ctx, x, y);
-            cairo_show_text(ctx, modifier_string);
-            cairo_close_path(ctx);
+            cairo_text_extents(msg_ctx, modifier_string, &extents);
+            x = msg_width/2 - extents.width/2;
+            y = extents.height/2 - extents.y_bearing + 28.0;
+
+            cairo_move_to(msg_ctx, x, y);
+            cairo_show_text(msg_ctx, modifier_string);
+            cairo_close_path(msg_ctx);
         }
 
-        /* After the user pressed any valid key or the backspace key, we
-         * highlight a random part of the unlock indicator to confirm this
-         * keypress. */
-        if (unlock_state == STATE_KEY_ACTIVE ||
-            unlock_state == STATE_BACKSPACE_ACTIVE) {
-            cairo_new_sub_path(ctx);
-            double highlight_start = (rand() % (int)(2 * M_PI * 100)) / 100.0;
-            cairo_arc(ctx,
-                      BUTTON_CENTER /* x */,
-                      BUTTON_CENTER /* y */,
-                      BUTTON_RADIUS /* radius */,
-                      highlight_start,
-                      highlight_start + (M_PI / 3.0));
-            if (unlock_state == STATE_KEY_ACTIVE) {
-                /* For normal keys, we use a lighter green. */
-                cairo_set_source_rgb(ctx, 51.0 / 255, 219.0 / 255, 0);
-            } else {
-                /* For backspace, we use red. */
-                cairo_set_source_rgb(ctx, 219.0 / 255, 51.0 / 255, 0);
-            }
-            cairo_stroke(ctx);
-
-            /* Draw two little separators for the highlighted part of the
-             * unlock indicator. */
-            cairo_set_source_rgb(ctx, 0, 0, 0);
-            cairo_arc(ctx,
-                      BUTTON_CENTER /* x */,
-                      BUTTON_CENTER /* y */,
-                      BUTTON_RADIUS /* radius */,
-                      highlight_start /* start */,
-                      highlight_start + (M_PI / 128.0) /* end */);
-            cairo_stroke(ctx);
-            cairo_arc(ctx,
-                      BUTTON_CENTER /* x */,
-                      BUTTON_CENTER /* y */,
-                      BUTTON_RADIUS /* radius */,
-                      (highlight_start + (M_PI / 3.0)) - (M_PI / 128.0) /* start */,
-                      highlight_start + (M_PI / 3.0) /* end */);
-            cairo_stroke(ctx);
-        }
     }
 
     if (xr_screens > 0) {
+
         /* Composite the unlock indicator in the middle of each screen. */
         for (int screen = 0; screen < xr_screens; screen++) {
-            int x = (xr_resolutions[screen].x + ((xr_resolutions[screen].width / 2) - (button_diameter_physical / 2)));
-            int y = (xr_resolutions[screen].y + ((xr_resolutions[screen].height / 2) - (button_diameter_physical / 2)));
-            cairo_set_source_surface(xcb_ctx, output, x, y);
-            cairo_rectangle(xcb_ctx, x, y, button_diameter_physical, button_diameter_physical);
+            double x, y;
+            int offset = top_margin;
+
+            if (image_loaded) {
+                x = (xr_resolutions[screen].x + ((xr_resolutions[screen].width / 2) - (lock_width / 2)));
+                y = (xr_resolutions[screen].y + ((xr_resolutions[screen].height / 2) - (lock_height / 2))) + offset;
+                cairo_set_source_surface(xcb_ctx, lock_surface, x, y);
+                cairo_paint(xcb_ctx);
+                offset += psw_top_margin;
+            }
+
+            x = (xr_resolutions[screen].x + ((xr_resolutions[screen].width / 2) - (psw_width / 2)));
+            y = (xr_resolutions[screen].y + ((xr_resolutions[screen].height / 2) - (psw_height / 2))) + offset;
+            cairo_set_source_surface(xcb_ctx, psw_surface, x, y);
+            cairo_rectangle(xcb_ctx, x, y, psw_width, psw_height);
+            cairo_fill(xcb_ctx);
+            offset += msg_top_margin;
+
+            x = (xr_resolutions[screen].x + ((xr_resolutions[screen].width / 2) - (msg_width / 2)));
+            y = (xr_resolutions[screen].y + ((xr_resolutions[screen].height / 2) - (msg_height / 2))) + offset;
+            cairo_set_source_surface(xcb_ctx, msg_surface, x, y);
+            cairo_rectangle(xcb_ctx, x, y, msg_width, msg_height);
             cairo_fill(xcb_ctx);
         }
+
     } else {
+
         /* We have no information about the screen sizes/positions, so we just
          * place the unlock indicator in the middle of the X root window and
          * hope for the best. */
-        int x = (last_resolution[0] / 2) - (button_diameter_physical / 2);
-        int y = (last_resolution[1] / 2) - (button_diameter_physical / 2);
-        cairo_set_source_surface(xcb_ctx, output, x, y);
-        cairo_rectangle(xcb_ctx, x, y, button_diameter_physical, button_diameter_physical);
+        double x, y;
+        int offset = top_margin;
+
+        if (image_loaded) {
+            x = (last_resolution[0] / 2) - (lock_width / 2);
+            y = (last_resolution[1] / 2) - (lock_height / 2) + offset;
+            cairo_set_source_surface(xcb_ctx, lock_surface, x, y);
+            cairo_paint(xcb_ctx);
+            offset += psw_top_margin;
+        }
+
+        x = (last_resolution[0] / 2) - (psw_width / 2);
+        y = (last_resolution[1] / 2) - (psw_height / 2) + offset;
+        cairo_set_source_surface(xcb_ctx, psw_surface, x, y);
+        cairo_rectangle(xcb_ctx, x, y, psw_width, psw_height);
+        cairo_fill(xcb_ctx);
+        offset += msg_top_margin;
+
+        x = (last_resolution[0] / 2) - (msg_width / 2);
+        y = (last_resolution[1] / 2) - (msg_height / 2) + offset;
+        cairo_set_source_surface(xcb_ctx, msg_surface, x, y);
+        cairo_rectangle(xcb_ctx, x, y, msg_width, msg_height);
         cairo_fill(xcb_ctx);
     }
 
     cairo_surface_destroy(xcb_output);
-    cairo_surface_destroy(output);
-    cairo_destroy(ctx);
+    cairo_surface_destroy(psw_surface);
+    cairo_surface_destroy(lock_surface);
     cairo_destroy(xcb_ctx);
+    cairo_destroy(psw_ctx);
+    cairo_destroy(lock_ctx);
     return bg_pixmap;
 }
 
