
" INIT
" ----------------------------------------------------------------------------

	if empty($XDG_CONFIG_HOME)
		let $XDG_CONFIG_HOME = $HOME.'/.config'
	end
	if empty($XDG_DATA_HOME)
		let $XDG_DATA_HOME = $HOME.'/.local/share'
	end
	if empty($XDG_CACHE_HOME)
		let $XDG_CACHE_HOME = $HOME.'/.cache'
	end

	let $VIMHOME = empty($VIMHOME) ? $XDG_CONFIG_HOME.'/vim' : $VIMHOME
	let $VIMCACHE = empty($VIMCACHE) ? $XDG_CACHE_HOME.'/vim' : $VIMCACHE
	let $VIMDATA = empty($VIMDATA) ? $XDG_DATA_HOME.'/vim' : $VIMDATA

	let &rtp = substitute(&rtp, $HOME.'/.vim', $VIMHOME, 'g')

" PLUGINS
" ----------------------------------------------------------------------------

	comm! -nargs=1 Local exec printf("Plug '%s/plugins/%s'", $VIMHOME, <args>)

	call plug#begin($VIMDATA . '/plugins')

	Plug 'w0rp/ale'
	Plug 'tpope/vim-fugitive'
	Plug 'airblade/vim-gitgutter'
	Plug 'SirVer/ultisnips'
	Plug 'wellle/targets.vim'
	Plug 'ap/vim-css-color'
	Plug 'prabirshrestha/vim-lsp'
	Plug 'prabirshrestha/async.vim'

	Plug 'posva/vim-vue'
	Plug 'pangloss/vim-javascript'
	Plug 'JulesWang/css.vim'
	Plug 'othree/html5.vim'
	Plug 'elixir-lang/vim-elixir'
	Plug 'tpope/vim-markdown'
	Plug 'stephpy/vim-yaml'

	Local 'rofi'
	Local 'grep'
	Local 'pairs'
	Local 'autotype'
	Local 'taggify'
	Local 'qfedit'
	Local 'spotter'
	Local 'explorer'
	Local 'commenter'
	Local 'bookmarks'
	Local 'finder'
	Local 'buffers'
	Local 'tagmaker'
	Local 'taglist'
	Local 'python'
	Local 'term'

	call plug#end()

	delcomm Local

" OPTIONS
" ----------------------------------------------------------------------------

	syntax on
	filetype plugin on

	set history=100
	set viminfo=!,'100,h,n$VIMCACHE/viminfo

	set undofile
	set undodir=$VIMCACHE/undofiles

	set noswapfile
	set nobackup

	set backspace=indent,eol,start
	set encoding=utf8
	set spelllang=it,en
	set cryptmethod=blowfish
	set updatetime=300
	set timeoutlen=1000
	set ttimeoutlen=10
	set lazyredraw
	set hidden
	set autoread
	set path=**

	set ignorecase
	set smartcase
	set showmatch
	set incsearch
	set nohlsearch
	set gdefault

	let mapleader = "\<space>"

" UI
" ----------------------------------------------------------------------------

	let g:html_no_rendering = 1
	let g:vim_json_warnings = 0

	colorscheme dark

	if has('termguicolors')
		set termguicolors
	end

	if exists('$TMUX')
		set cmdheight=2
	end

	set guioptions=c

	let &guifont = 'Noto Mono 10'
	set linespace=1

	set title
	let &titlestring = "%{getcwd()} - Vim"

	set nowrap
	set linebreak
	set breakindent
	set showbreak=..
	set display=lastline
	set textwidth=100

	set number
	set norelativenumber
	set numberwidth=1
	set nocursorline

	set scrolloff=0
	set sidescrolloff=0

	set virtualedit=all
	set mouse=a

	set noexpandtab
	set tabstop=3
	set shiftwidth=0
	set softtabstop=0
	set autoindent

	set wildmenu
	set wildmode=full
	set wildignore+=
	set wildignore+=*/venv/*,venv$
	set wildignore+=*/__pycache__/*,__pycache__
	set wildignore+=*/node_modules/*,node_modules
	set wildignore+=.git,.DS_Store,tags,.tags,*.retry
	set wildignore+=*.sqlite3,*.pyc,*.beam,*.so
	set wildignore+=*.jpg,*.jpeg,*.png,*.ico,*.gif

	set formatoptions=crq1nj
	set nrformats-=octal

	set splitbelow
	set splitright

	set nofoldenable
	set foldcolumn=0

	set completeopt=menuone,longest
	set nojoinspaces
	set report=9999
	set shortmess=FOIAoastc
	set noshowmode
	set showcmd
	set laststatus=2
	set visualbell
	set t_vb=

	set list
	set fillchars=vert:│
	let g:listchars = ',trail:·,precedes:‹,extends:›'
	let &listchars = 'tab:  ' . listchars

	nnoremap <silent> <leader>i :call <sid>toggle_indent_guides()<cr>
	func! s:toggle_indent_guides()
		let &listchars = (&listchars =~ 'tab:│' ? 'tab:  ' : 'tab:│ ') . g:listchars
	endf

" STATUSLINE
" ----------------------------------------------------------------------------

	let s:sep = ' ‹ '

	func! _current_buffer()
		if empty(bufname('%'))
			return '[no name]'
		end
		if !empty(&bt) || winwidth(0) < 80 || &ft == 'notes'
			return expand('%:t')
		end
		return join(split(expand('%:p:~'), '/')[-2:], '/')
	endf

	func! _alternate_buffer()
		let alt = expand('#:t')
		if empty(&bt) && winwidth(0) > 80 && !empty(alt) && expand('#:p') != expand('%:p')
			return '[' . alt . '] '
		end
		return ''
	endf

	func! _venv()
		if !&diff && &ft == 'python' && !empty($VIRTUAL_ENV)
			return '[' . fnamemodify($VIRTUAL_ENV, ':t') . '] '
		end
		return ''
	endf

	func! _git_branch()
		let branch = exists('*fugitive#head') ? fugitive#head() : ''
		if !&diff && !empty(branch) && winwidth(0) > 60
			return 'git:'.branch . s:sep
		end
		return ''
	endf

	func! _meta()
		let items = []
		let enc = printf('%s:%s', &fenc ? &fenc : &enc, &ff)
		if empty(&bt) && winwidth(0) > 80
			call add(items, &ft)
		end
		call filter(items, 'len(v:val)')
		return empty(items) ? '' : join(items, s:sep) . s:sep
	endf

	func! _flags()
		if winwidth(0) < 80
			return ''
		end
		let flags = []
		if !empty(getqflist())
			call add(flags, '[QF]')
		end
		if !empty(getloclist(0))
			call add(flags, '[LOC]')
		end
		return empty(flags) ? '' : '‹ ' . join(flags, '') . ' '
	endf

	let &stl  = ' '
	let &stl .= '%#StatusLineGreen#%{_venv()}%*'
	let &stl .= '%{_alternate_buffer()}'
	let &stl .= '%(%w%r%h %)'
	let &stl .= '%{&mod ? "" : _current_buffer()}'
	let &stl .= '%#StatusLineMod#%{&mod ? _current_buffer() : ""}%*'
	let &stl .= '%='
	let &stl .= '%{_git_branch()}'
	let &stl .= '%{_meta()}'
	let &stl .= '%1lL %02cC (%P) '
	let &stl .= '%{_flags()}'

" TABS
" ----------------------------------------------------------------------------

	set tabline=%!_tabline()

	func! _tabline()
		let tabline = ''
		for tabnr in range(1, tabpagenr('$'))
			let tabline .= tabnr == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
			let tabline .= ' %' . tabnr . 'T'
			let tabname = gettabvar(tabnr, 'tabname', '')
			let tabname = empty(tabname) ? 'TAB' : tabname
			let tabline .= printf('[ #%s %s ]', tabnr, tabname)
			let tabline .= ' '
		endfor
		let tabline .= '%#TabLineFill#%T'
		let tabline .= '%=%#TabLine#%999X'
		return tabline
	endf

	command! -nargs=? Tab tabe | TabName <args>
	command! -nargs=? TabName call <sid>set_tabname(<q-args>)

	func! s:set_tabname(name)
		let t:tabname = a:name
		set tabline=%!_tabline()
	endf

" WINDOWS
" ----------------------------------------------------------------------------

	aug _windows
		au!
		au VimResized * wincmd = | redraw
	aug END

	nnoremap <silent> <c-w>v <c-w>v:b#<cr>
	nnoremap <silent> <c-w>s <c-w>s:b#<cr>

	nnoremap <silent> <left> <c-w><
	nnoremap <silent> <right> <c-w>>
	nnoremap <silent> <up> <c-w>+
	nnoremap <silent> <down> <c-w>-

	command! -nargs=0 Zoom call <sid>zoom_toggle()
	nnoremap <silent> <c-w>z :Zoom<cr>

	func! s:zoom_toggle() abort
		if exists('w:zoom')
			exec w:zoom
			unlet w:zoom
		else
			let w:zoom = winrestcmd()
			wincmd _
			wincmd |
		end
	endf

" BUFFERS
" ----------------------------------------------------------------------------

	aug _buffers
		au!
		au BufReadPost * call setpos(".", getpos("'\""))
	aug END

	command! -bang -nargs=1 -complete=file Move call <sid>move(<q-bang>, <q-args>, getcwd())
	command! -bang -nargs=1 -complete=file Rename call <sid>move(<q-bang>, <q-args>, expand('%:p:h'))

	func! s:move(bang, dest, cwd)
		let alternate = @#
		let source = expand("%:p")
		let dest = a:cwd . '/' . a:dest
		try
			exec 'saveas'.a:bang fnameescape(dest)
			call delete(source)
			sil exec 'bwipe' fnameescape(source)
		catch
			let msg = substitute(v:exception, '\v^Vim\([^:]*:', '', '')
			echohl WarningMsg | echo msg | echohl None
		finally
			let @# = alternate
		endtry
	endf

	" switch to the alternate buffer
	nnoremap <c-a> <c-^>

" QUICKFIX
" ----------------------------------------------------------------------------

	let g:quickfix_height = 50

	nnoremap <silent> <leader>q :cwindow<cr>
	nnoremap <silent> ]q :cnext<cr>zz:set cul<cr>
	nnoremap <silent> ]Q :clast<cr>zz:set cul<cr>
	nnoremap <silent> [q :cprev<cr>zz:set cul<cr>
	nnoremap <silent> [Q :cfirst<cr>zz:set cul<cr>

	nnoremap <silent> <leader>l :lwindow<cr>
	nnoremap <silent> ]l :lnext<cr>zz:set cul<cr>
	nnoremap <silent> ]L :llast<cr>zz:set cul<cr>
	nnoremap <silent> [l :lprev<cr>zz:set cul<cr>
	nnoremap <silent> [L :lfirst<cr>zz:set cul<cr>

" EDITING
" ----------------------------------------------------------------------------

	inoremap <c-e> <esc>O
	inoremap <c-d> <esc>o
	inoremap <c-w> <c-g>u<c-w>
	inoremap <c-l> <right><bs>
	cnoremap <c-l> <right><bs>

	" create empty lines without leaving normal mode
	nnoremap <c-e> m`O<esc>"_cc<esc>``
	nnoremap <c-d> m`o<esc>"_cc<esc>``

	" toggle case or capitalization of the previous word
	inoremap <c-u> <nop>
	inoremap <c-u>c <esc>m`b~``a
	inoremap <c-u>u <esc>m`bg~iw``a

	" buffer text object
	vnoremap a% GoggV
	onoremap a% :<c-u>norm va%<cr>

	" blackhole register shortcut
	nnoremap _ "_
	vnoremap _ "_

	" + register shortcut
	nnoremap + "+
	vnoremap + "+

	" select the last changed text
	nnoremap <expr> gV '`[' . strpart(getregtype(), 0, 1) . '`]'

	" indent the last changed text
	nmap g= gV=

	" paste and indent (improved)
	nmap ]P Pg=
	nmap ]p pg=

	" replace selection without side effects
	vmap <expr> P '_d"' . v:register . 'P'
	vmap <expr> ]P '_d"' . v:register . ']P'

	" toggle paste
	nnoremap <leader>p :set paste!<bar>set paste?<cr>

	" copy to the end of the line
	nnoremap Y y$

	" indent lines without losing selection
	vnoremap < <gv
	vnoremap > >gv

" MOVING AROUND
" ----------------------------------------------------------------------------

	nnoremap ' `

	nnoremap <c-u> <c-e>

	inoremap <c-g>l <esc>la
	inoremap <c-g><c-l> <esc>la
	inoremap <c-g>h <esc>ha
	inoremap <c-g><c-h> <esc>ha

	noremap j gj
	noremap k gk

	noremap J 3gj
	noremap K 3gk

	noremap M %
	noremap H ^
	noremap L g_

	noremap <c-k> {
	noremap <c-j> }

	noremap <silent> gw :<c-u>call <sid>next_word(0)<cr>
	noremap <silent> gb :<c-u>call <sid>next_word(1)<cr>

	" move to the next/previous word that starts with word characters
	func! s:next_word(backward)
		let flags = 'We' . (a:backward ? 'b' :'')
		for _ in range(1, v:count1)
			call searchpos('\v(\W|^)\w', flags)
		endfor
	endf

	" jump after given characters without leaving insert mode
	inoremap <silent> <c-f> <c-r>=_jump_after('\v['.join([']',')','}','>','"',"'"],'').']')<cr>

	func! _jump_after(pattern)
		return search(a:pattern, 'Wce') ? "\<right>" : ''
	endf

" SEARCH AND SUBSTITUTE
" ---------------------------------------------------------------------------

	aug _hlsearch
		au!
		if exists("##CmdlineEnter")
			au CmdlineEnter [/\?] set hlsearch
			au CmdlineLeave [/\?] set nohlsearch
		end
	aug END

	" use <tab> and <s-tab> instead of <c-g> and <c-t>
	cnoremap <expr> <tab> getcmdtype() =~ '[?/]' ? '<c-g>' : feedkeys('<tab>', 'int')[1]
	cnoremap <expr> <s-tab> getcmdtype() =~ '[?/]' ? '<c-t>' : feedkeys('<s-tab>', 'int')[1]

	noremap <c-b> ?
	noremap <c-f> /

	" toggle highlighting of the last search pattern
	nnoremap <silent> <c-h> :set hlsearch!<bar>set hlsearch?<cr>

	" Search for current word or selected text without moving the cursor.
	" let &hls = &hls is needed to force highlighting
	nnoremap <silent> S :call <sid>search(0)<cr>:let &hls = &hls<cr>
	vnoremap <silent> S :<c-u>call <sid>search(1)<cr>:let &hls = &hls<cr>

	" Toggle search for current word or selected text without moving the cursor
	fun! s:search(visual)
		if a:visual && line("'<") != line("'>")
			return
		end
		if a:visual
			let selection = getline('.')[col("'<")-1:col("'>")-1]
			let pattern = '\V' . escape(selection, '/\')
		else
			 let pattern = '\<' . expand('<cword>') . '\>'
		end
		if @/ == pattern
			let @/ = ''
			set nohlsearch
		else
			let @/ = pattern
			set hlsearch
		end
	endf

" YANK FEEDBACK
" ----------------------------------------------------------------------------

	aug _yankhl
		au!
		if exists("##TextYankPost") && has('timers')
			au TextYankPost * call <sid>yankhl()
		end
	aug END

	func! s:yankhl()
		if v:event.operator != 'y' || v:event.regname == '*'
			return
		end
		let lines = v:event.regcontents
		call map(lines, {-> escape(v:val, '\\')})
		if !empty(lines) && empty(lines[-1])
			let lines[-1] = '\n'
		end
		let pattern = printf('\V\%%%dl\%%%dc%s', line("'["), col("'["), join(lines, '\n'))
		let id = matchadd("Yank", pattern, -1)
		call timer_start(300, {-> call('matchdelete', [id])})
	endf

" MACROS
" ----------------------------------------------------------------------------

	vnoremap @ :norm! @

	nnoremap Q @q
	vnoremap <silent> Q :norm! @q<cr>

	" edit register q
	nnoremap <silent> <leader>@ :<c-r><c-r>='let @q = '.string(getreg('q'))<cr><c-f><left>:res 1<cr>

" TAGS
" ----------------------------------------------------------------------------

	set tags=
	let g:tags_common = ['tags']

	aug _tags
		au!
		au FileType * call _set_tagfiles()
		au User TagMakerPost call _set_tagfiles()
	aug END

	" The order of tags file will determine in what position Taglist will display
	" them. Prefix them with a number followed by a dot to enforce an ordering:
	" ie. results from 0.project will always be displayed on top.
	" To ignore a tag file, prefix its name with an underscore.
	func! _set_tagfiles()
		let local_tags = glob('.tags/'.&ft.'/[^_]*', 1, 1)
		let global_tags = glob($XDG_DATA_HOME.'/tags/'.&ft.'/[^_]*', 1, 1)
		let tagfiles = local_tags + global_tags + g:tags_common
		call setbufvar(bufnr('%'), '&tags', join(tagfiles, ','))
	endf

" PROJECT
" ----------------------------------------------------------------------------

	let g:root_markers = ['.gitignore', 'node_modules']

	aug _project_util
		au!
		au VimEnter * sil! CdRoot
	aug END

	nnoremap <leader>c :lcd %:p:h<cr>:pwd<cr>
	nnoremap <leader>C :CdRoot<cr>

	command! -bang -nargs=0 CdRoot call <sid>cd_into_root(<q-bang>)

	" Find project root
	func! s:find_root(path)
		if empty(a:path) || a:path == '/'
			return ''
		end
		let files = glob(a:path.'/.*', 1, 1) + glob(a:path.'/*', 1, 1)
		let pattern = '\V\^\(' . join(get(g:, 'root_markers', []), '\|') . '\)\$'
		if match(map(files, "fnamemodify(v:val, ':t')"), pattern) >= 0
			return a:path
		end
		return s:find_root(fnamemodify(a:path, ':h'))
	endf

	" Cd into the current project root
	func! s:cd_into_root(bang)
		let path = s:find_root(expand('%:p:h'))
		if !empty(path)
			let cmd = empty(a:bang) ? 'cd' : 'lcd'
			exec cmd fnameescape(path)
			pwd
		end
	endf

" TRAILINGS
" ----------------------------------------------------------------------------

	aug _strip
		au!

		au BufWritePre * call <sid>strip_trailing_lines()
		au BufWritePre * call <sid>strip_trailing_spaces()

		au BufEnter,BufNewFile * let b:strip_spaces = 1
		au BufEnter,BufNewFile *.py let b:strip_lines = 1

	aug END

	func! s:strip_trailing_spaces()
		if &ft != 'diff' && get(g:, 'strip_spaces', 1) && get(b:, 'strip_spaces', 0)
			call _s('\v\s+$', '', 'e')
		end
	endf

	func! s:strip_trailing_lines()
		if &ft != 'diff' && get(g:, 'strip_lines', 1) && get(b:, 'strip_lines', 0)
			call _s('\v($\n\s*)+%$', '', '')
		end
	endf

" MISC
" ----------------------------------------------------------------------------

	aug _misc
		au!

		au BufWritePost *vimrc source $MYVIMRC
		au BufWritePost */colors/* nested exec 'colorscheme' g:colors_name

		au CmdWinEnter * set ft=
		au CmdWinEnter * noremap <buffer> <c-j> <cr>
		au CmdWinEnter * noremap <buffer> q <c-w>c
		au CmdWinEnter * setl nonumber norelativenumber

		" Keep clipboard content
		au VimLeave * call system("xclip -sel clip -i", getreg('+'))

		" Keep the help window to the bottom when there are multiple splits
		au BufWinEnter * if &ft == 'help' | wincmd J | end
		au BufWinEnter * if &ft == 'help' | nnoremap <silent> <buffer> q :bdelete<cr> | end

		" Show cursorline only for a short amount of time
		au CursorHold,CursorHoldI * if &ft !~ '\v^(qf|netrw|explorer|buffers|finder|bookmarks|taglist)$' | set nocul | end

		au BufReadPost * if &key != '' | setl noudf noswf nowb nobk nostmp secure hi=0 vi= | end
		au BufNewFile,BufReadPre /tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*,*/shm/* setl secure nostmp nowb nobk noswf hi=0 vi=
		au BufWritePre /tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*,*/shm/* setl noudf

	aug END

	" Execute the :s command without messing jumps or cursor
	func! _s(pattern, string, flags)
		let view = winsaveview()
		sil! exec 'keepj' 'keepp' '%s/'.a:pattern.'/'.a:string.'/'.a:flags
		call winrestview(view)
	endf

	command! -nargs=0 ClearUndo call <sid>clear_undo()

	" Clear undo history (:h clear-undo)
	func! s:clear_undo()
		let modified_save = &modified
		let undolevels_save = &undolevels
		let line_save = getline('.')
		set undolevels=-1
		exec "norm! a \<bs>\<esc>"
		call setline('.', line_save)
		let &undolevels = undolevels_save
		let &modified = modified_save
	endf

	" Edit filetype plugin
	command! -nargs=? -complete=filetype Ftedit call <sid>ft_edit(<q-args>)

	func! s:ft_edit(ft)
		let ft = empty(a:ft) ? &ft : a:ft
		let paths = []
		call extend(paths, split(globpath(&rtp, 'after/ftplugin/'.ft.'.vim')))
		call extend(paths, split(globpath(&rtp, 'plugins/ftplugin/'.ft.'.vim')))
		call filter(paths, "v:val =~ '\\V\\^'.$VIMHOME")
		if !empty(paths)
			exec 'edit' fnameescape(paths[0])
		else
			" create the file if it doesn't exist
			let path = $VIMHOME.'/after/ftplugin/'.ft.'.vim'
			exec 'edit' fnameescape(path)
		end
	endf

	command! -nargs=0 Vimrc edit $MYVIMRC
	command! -nargs=0 Coloredit  exec 'e' $VIMHOME.'/colors/' . g:colors_name . '.vim'

	" Save the current buffer as sudo
	command! -nargs=0 Sudow exec 'write !sudo tee % > /dev/null'

	" Execute commands silently and redraw
	command! -nargs=+ Sil exec 'sil!' <q-args> | redraw!

	" Returns the syntax group under the cursor
	func! _syntax()
		return synIDattr(synIDtrans(synID(line('.'), col('.'), 0)), 'name')
	endf

	inoremap <c-c> <c-]><esc>
	inoremap <c-z> <esc><c-z>

	cnoremap <c-n> <down>
	cnoremap <c-p> <up>

	noremap <leader>j J
	noremap <leader>k K

	nnoremap <leader>v :source .vimrc<cr>

	nnoremap <silent> <leader>w :set wrap!<bar>set wrap?<cr>
	nnoremap <silent> <leader>n :set number!<bar>set number?<cr>
	nnoremap <silent> <leader>z :let &scrolloff = abs(&scrolloff - 999)<bar>set scrolloff?<cr>

	iabbrev teh the
	iabbrev wiht with
	iabbrev lenght length
	iabbrev retrun return

" Grep
" ----------------------------------------------------------------------------

	nnoremap <leader>s :Grep!<space>
	nnoremap <silent> <leader>S :Grep! <c-r><c-w><cr>

" Buffers
" ----------------------------------------------------------------------------

	nnoremap <silent> <leader>a :Buffers<cr>

" Bookmarks
" ----------------------------------------------------------------------------

	nnoremap <silent> <leader>? :Bookmarks<cr>
	nnoremap <silent> <leader>' :call bookmarks#jump(getchar())<cr>
	nnoremap <silent> <leader>m :call bookmarks#set(getchar(), expand('%:p'))<cr>
	nnoremap <silent> <leader>M :call bookmarks#set(getchar(), expand('%:p:h'))<cr>

" Taglist
" ----------------------------------------------------------------------------

	nnoremap <leader>t :Tag!<space>
	nnoremap <silent> <leader>T :Tag! <c-r><c-w><cr>
	nnoremap <silent> <c-]> :Tag <c-r><c-w><cr>

" Spotter
" ----------------------------------------------------------------------------

	let g:spotter_banned_filetypes = {
		\ 'html':1, 'jinja':1, 'htmldjango':1, "json":1,
	   \ 'text':1, 'markdown':1, 'notes':1,
	\ }

	let g:spotter_banned_syntax = {
		\ 'String':1, 'Comment':1,
	\ }

	let g:spotter_banned_syntax_elixir = {
		\ 'elixirDocString':1
	\ }

	let g:spotter_banned_words_javascript = {
		\ 'var':1, 'let':1, 'const':1, 'function':1, 'class':1
	\ }

" Ale
" ----------------------------------------------------------------------------

	highlight link ALEError None
	highlight link ALEErrorSign Exception
	highlight link ALEWarningSign Repeat

	let g:ale_sign_error = 'x'
	let g:ale_sign_warning = '!'
	let ale_lint_on_text_changed = 'never'
	let g:ale_open_list = 0

" Explorer
" ----------------------------------------------------------------------------

	nnoremap <silent> <leader>e :exec 'Explorer' expand('%:p:h')<cr>
	nnoremap <silent> <leader>E :exec 'Explorer' getcwd()<cr>

	let g:explorer_hide = '^\.git$'

" Netrw
" ----------------------------------------------------------------------------

	let g:netrw_banner = 0
	let g:netrw_altfile = 1
	let g:netrw_liststyle = 0

	let g:netrw_list_hide = ''
	let g:netrw_list_hide .= '\(^\|\s\s\)\zs\.\S\+,'
	let g:netrw_list_hide .= '\./,\.\./,'
	let g:netrw_list_hide .= '\.DS_Store,\.pyc$'

" Ultisnips
" ----------------------------------------------------------------------------

	let g:UltiSnipsExpandTrigger = '<c-s>'
	let g:UltiSnipsJumpForwardTrigger = '<c-s>'
	" let g:UltiSnipsSnippetsDir = $VIMHOME . '/UltiSnips'

" Targets
" ----------------------------------------------------------------------------

	omap ia Ia
	omap i, I,

	let g:targets_argOpening = '[({[]'
	let g:targets_argClosing = '[]})]'

" GitGutter
" ----------------------------------------------------------------------------

	let g:gitgutter_enabled = 0

" LSP
" ----------------------------------------------------------------------------

	let g:lsp_async_completion = 1

	if executable('pyls')
		" pip install python-language-server
		au User lsp_setup call lsp#register_server({
			\ 'name': 'pyls',
			\ 'cmd': {server_info->['pyls']},
			\ 'whitelist': ['python'],
		\ })
	end

" Disable unused plugins
" ----------------------------------------------------------------------------

	let g:loaded_logiPat = 1
	let g:loaded_vimballPlugin = 1
	let g:loaded_getscriptPlugin = 1
