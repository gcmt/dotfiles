
" INIT
" ----------------------------------------------------------------------------

	if !exists('$XDG_CONFIG_HOME')
		let $XDG_CONFIG_HOME = $HOME.'/.config'
	end

	if !exists('$XDG_DATA_HOME')
		let $XDG_DATA_HOME = $HOME.'/.local/share'
	end

	if !exists('$XDG_CACHE_HOME')
		let $XDG_CACHE_HOME = $HOME.'/.cache'
	end

	if !exists('$VIMHOME')
		let s:rcdir = fnamemodify(expand('<sfile>'), ':h')
		let $VIMHOME = isdirectory(s:rcdir.'/.vim') ? s:rcdir.'/.vim' : s:rcdir
	end

	if !exists('$VIMCACHE')
		let $VIMCACHE = $XDG_CACHE_HOME.'/vim'
	end

	if !exists('$VIMDATA')
		let $VIMDATA = $XDG_DATA_HOME.'/vim'
	end

	if !exists('$VIMPLUGS')
		let $VIMPLUGS = join([$VIMDATA.'/plugins', $VIMHOME.'/plugins'], ':')
	end

	func! s:find_plugins()
		let plugins = []
		for path in split($VIMPLUGS, ':')
			call extend(plugins, filter(glob(path.'/[^_]*', 1, 1), 'isdirectory(v:val)'))
		endfor
		return plugins
	endf

	func! s:set_rtp()
		let rtp = []
		let plugins = s:find_plugins()
		call add(rtp, $VIMHOME)
		call extend(rtp, plugins)
		call add(rtp, $VIM.'/vimfiles')
		call add(rtp, $VIMRUNTIME)
		call add(rtp, $VIM.'/vimfiles/after')
		call extend(rtp, globpath(join(plugins, ','), 'after', 1, 1))
		call add(rtp, $VIMHOME.'/after')
		let &rtp = join(rtp, ',')
	endf

	func! s:helptags()
		for docdir in globpath(join(s:find_plugins(), ','), 'doc', 1, 1)
			exec 'helptags' docdir
		endfor
	endf

	if !empty($VIMHOME)

		aug _rtp
			au!
			au User UpdateRtp call <sid>set_rtp()
		aug END

		call s:set_rtp()

		comm! Helptags call <sid>helptags()

	end

" PLUGINS
" ----------------------------------------------------------------------------

	if !empty($VIMDATA)
		let g:plugs_path = $VIMDATA.'/plugins'
	end

	let g:plugs_list = [
		\ 'https://github.com/w0rp/ale',
		\ 'https://github.com/tpope/vim-fugitive',
		\ 'https://github.com/airblade/vim-gitgutter',
		\ 'https://github.com/SirVer/ultisnips',
		\ 'https://github.com/ap/vim-css-color',
		\ 'https://github.com/posva/vim-vue',
		\ 'https://github.com/pangloss/vim-javascript',
		\ 'https://github.com/JulesWang/css.vim',
		\ 'https://github.com/othree/html5.vim',
		\ 'https://github.com/elixir-lang/vim-elixir',
		\ 'https://github.com/tpope/vim-markdown',
		\ 'https://github.com/stephpy/vim-yaml',
	\ ]

" OPTIONS
" ----------------------------------------------------------------------------

	syntax on
	filetype plugin indent on

	if empty($VIMCACHE)
		set viminfo=
		set noundofile
	else
		set viminfo=!,'100,f0
		set viminfofile=$VIMCACHE/viminfo
		set undofile
		set undodir=$VIMCACHE/undo
	end

	set directory=
	set noswapfile

	set history=100
	set backspace=indent,eol,start
	set encoding=utf8
	set spelllang=it,en
	set cryptmethod=blowfish
	set updatetime=300
	set timeoutlen=1000
	set ttimeoutlen=10
	set lazyredraw
	set hidden
	set autoread
	set path=**

	set ignorecase
	set smartcase
	set showmatch
	set incsearch
	set nohlsearch

	let mapleader = "\<space>"

" UI
" ----------------------------------------------------------------------------

	func! s:get_term_bg()
		let bg = matchstr(system('xrdb -query all | grep colorscheme | grep -o "\S\+$"'), '\v\w+')
		return empty(bg) ? 'dark' : bg
	endf

	func! s:toggle_bg()
		let &bg = &bg == 'dark' ? 'light' : 'dark'
		if executable('colorscheme')
			exec 'sil!' '!colorscheme' &bg
		end
	endf

	nnoremap <silent> gob :call <sid>toggle_bg()<cr>

	let g:html_no_rendering = 1
	let g:vim_json_warnings = 0

	let &bg = s:get_term_bg()
	colorscheme main

	if exists('$TMUX')
		set cmdheight=1
	end

	set guioptions=c

	let &guifont = 'Noto Mono Patched 10'
	set linespace=1

	set title
	let &titlestring = "%{getcwd()} - Vim"

	set nowrap
	set linebreak
	set breakindent
	set showbreak=..
	set display=lastline
	set textwidth=80

	set number
	set norelativenumber
	set numberwidth=1
	set nocursorline

	set scrolloff=0
	set sidescrolloff=0

	set virtualedit=block,onemore
	set mouse=a

	set noexpandtab
	set tabstop=3
	set shiftwidth=0
	set softtabstop=0
	set autoindent

	set wildmenu
	set wildmode=full
	set wildignore+=
	set wildignore+=*/venv/*,venv$
	set wildignore+=*/__pycache__/*,__pycache__
	set wildignore+=*/node_modules/*,node_modules
	set wildignore+=.git,.DS_Store,tags,.tags,*.retry
	set wildignore+=*.sqlite3,*.pyc,*.beam,*.so
	set wildignore+=*.jpg,*.jpeg,*.png,*.ico,*.gif

	set formatoptions=crq1nj
	set nrformats-=octal

	set splitbelow
	set splitright

	set nofoldenable
	set foldcolumn=0

	set completeopt=menuone,longest
	set nojoinspaces
	set report=9999
	set shortmess=FOIAoastc
	set noshowmode
	set showcmd
	set laststatus=2
	set visualbell
	set t_vb=

	set list
	set fillchars=vert:│
	let g:listchars = ',trail:·,precedes:‹,extends:›'
	let &listchars = 'tab:  ' . listchars

	nnoremap <silent> goi :call <sid>toggle_indent_guides()<cr>
	func! s:toggle_indent_guides()
		let &listchars = (&listchars =~ 'tab:│' ? 'tab:  ' : 'tab:│ ') . g:listchars
	endf

" STATUSLINE
" ----------------------------------------------------------------------------

	let s:sep = ' ‹ '

	func! _current_buffer()
		if empty(bufname('%'))
			return '[no name]'
		end
		if !empty(&bt) || winwidth(0) < 80 || &ft == 'notes'
			return expand('%:t')
		end
		return join(split(expand('%:p:~'), '/')[-2:], '/')
	endf

	func! _alternate_buffer()
		let alt = expand('#:t')
		if empty(&bt) && winwidth(0) > 80 && !empty(alt) && expand('#:p') != expand('%:p')
			return '[' . alt . '] '
		end
		return ''
	endf

	func! _venv()
		if !&diff && &ft == 'python' && !empty($VIRTUAL_ENV)
			return 'py:' . fnamemodify($VIRTUAL_ENV, ':t') . s:sep
		end
		return ''
	endf

	func! _git_branch()
		let branch = exists('*fugitive#head') ? fugitive#head() : ''
		if !&diff && !empty(branch) && winwidth(0) > 60
			return 'git:'.branch . s:sep
		end
		return ''
	endf

	func! _meta()
		let items = []
		let enc = printf('%s:%s', &fenc ? &fenc : &enc, &ff)
		if empty(&bt) && winwidth(0) > 80
			call add(items, &ft)
		end
		call filter(items, 'len(v:val)')
		return empty(items) ? '' : join(items, s:sep) . s:sep
	endf

	func! _flags()
		if winwidth(0) < 80
			return ''
		end
		let flags = []
		if !empty(getqflist())
			call add(flags, '[QF]')
		end
		if !empty(getloclist(0))
			call add(flags, '[LOC]')
		end
		return empty(flags) ? '' : '‹ ' . join(flags, '') . ' '
	endf

	let &stl  = ' '
	let &stl .= '%{_alternate_buffer()}'
	let &stl .= '%(%w%r%h %)'
	let &stl .= '%{&mod ? "" : _current_buffer()}'
	let &stl .= '%#StatusLineMod#%{&mod ? _current_buffer() : ""}%*'
	let &stl .= '%='
	let &stl .= '%{_git_branch()}'
	let &stl .= '%{_venv()}'
	let &stl .= '%{_meta()}'
	let &stl .= '%1lL %02cC (%P) '
	let &stl .= '%{_flags()}'

" TABS
" ----------------------------------------------------------------------------

	set tabline=%!_tabline()

	func! _tabline()
		let tabline = ''
		for tabnr in range(1, tabpagenr('$'))
			let tabline .= tabnr == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
			let tabline .= ' %' . tabnr . 'T'
			let tabname = gettabvar(tabnr, 'tabname', '')
			let tabname = empty(tabname) ? 'TAB' : tabname
			let tabline .= printf('[ #%s %s ]', tabnr, tabname)
			let tabline .= ' '
		endfor
		let tabline .= '%#TabLineFill#%T'
		let tabline .= '%=%#TabLine#%999X'
		return tabline
	endf

	command! -nargs=? Tab tabe | TabName <args>
	command! -nargs=? TabName call <sid>set_tabname(<q-args>)

	func! s:set_tabname(name)
		let t:tabname = a:name
		set tabline=%!_tabline()
	endf

	" when there is only one tab, open a new one
	nnoremap <silent> gt :exec tabpagenr('$') == 1 ? 'tab split' : 'norm! gt'<cr>

" WINDOWS
" ----------------------------------------------------------------------------

	aug _windows
		au!
		au VimResized * wincmd = | redraw
	aug END

	" view current buffer in a new tab
	nnoremap <c-w>t :tabe %<cr>

	nnoremap <silent> <c-w>v <c-w>v:b#<cr>
	nnoremap <silent> <c-w>s <c-w>s:b#<cr>

	nnoremap <silent> <left> 3<c-w><
	nnoremap <silent> <right> 3<c-w>>
	nnoremap <silent> <up> <c-w>+
	nnoremap <silent> <down> <c-w>-

	command! -nargs=0 Zoom call <sid>zoom_toggle()
	nnoremap <silent> <c-w>_ :Zoom<cr>

	func! s:zoom_toggle() abort
		if exists('w:zoom')
			exec w:zoom
			unlet w:zoom
		else
			let w:zoom = winrestcmd()
			wincmd _
			wincmd |
		end
	endf

" BUFFERS
" ----------------------------------------------------------------------------

	aug _buffers
		au!
		au BufReadPost * call setpos(".", getpos("'\""))
	aug END

	" switch to the alternate buffer
	nnoremap <c-a> <c-^>

" QUICKFIX
" ----------------------------------------------------------------------------

	let g:quickfix_height = 50

	nnoremap <silent> gxq :cwindow<cr>
	nnoremap <silent> ]q :cnext<cr>zz:set cul<cr>
	nnoremap <silent> ]Q :clast<cr>zz:set cul<cr>
	nnoremap <silent> [q :cprev<cr>zz:set cul<cr>
	nnoremap <silent> [Q :cfirst<cr>zz:set cul<cr>

	nnoremap <silent> gxl :lwindow<cr>
	nnoremap <silent> ]l :lnext<cr>zz:set cul<cr>
	nnoremap <silent> ]L :llast<cr>zz:set cul<cr>
	nnoremap <silent> [l :lprev<cr>zz:set cul<cr>
	nnoremap <silent> [L :lfirst<cr>zz:set cul<cr>

" EDITING
" ----------------------------------------------------------------------------

	inoremap <c-e> <esc>O
	inoremap <c-d> <esc>o
	inoremap <c-w> <c-g>u<c-w>
	inoremap <c-l> <right><bs>
	cnoremap <c-l> <right><bs>

	" create empty lines without leaving normal mode
	nnoremap <silent> <c-e> :<c-u>call append(line('.')-1, map(range(v:count1), "''"))<cr>
	nnoremap <silent> <c-d> :<c-u>call append(line('.'), map(range(v:count1), "''"))<cr>

	" toggle case or capitalization of the previous word
	inoremap <c-t>c <esc>m`b~``a
	inoremap <c-t>u <esc>m`bg~iw``a

	" buffer text object
	vnoremap a% GoggV
	onoremap a% :<c-u>norm va%<cr>

	" blackhole register shortcut
	nnoremap _ "_
	vnoremap _ "_

	" + register shortcut
	nnoremap + "+
	vnoremap + "+

	" select the last changed text
	nnoremap <expr> gV '`[' . strpart(getregtype(), 0, 1) . '`]'

	" indent the last changed text
	nmap g= gV=

	" paste and indent (improved)
	nmap ]P Pg=
	nmap ]p pg=

	" replace selection without side effects
	vmap <expr> P '_d"' . v:register . 'P'
	vmap <expr> ]P '_d"' . v:register . ']P'

	" toggle paste
	nnoremap gop :set paste!<bar>set paste?<cr>

	" copy to the end of the line
	nnoremap Y y$

	" indent lines without losing selection
	vnoremap < <gv
	vnoremap > >gv

" MOVING AROUND
" ----------------------------------------------------------------------------

	nnoremap ' `

	nnoremap <c-u> <c-e>

	inoremap <c-g>l <esc>la
	inoremap <c-g><c-l> <esc>la
	inoremap <c-g>h <esc>ha
	inoremap <c-g><c-h> <esc>ha

	noremap j gj
	noremap k gk

	noremap J 3gj
	noremap K 3gk

	noremap M %
	noremap H ^
	noremap L g_

	noremap <c-k> {
	noremap <c-j> }

	noremap <bs> <c-b>
	noremap <cr> <c-f>

	noremap <silent> gw :<c-u>call <sid>next_word(0)<cr>
	noremap <silent> gb :<c-u>call <sid>next_word(1)<cr>

	" move to the next/previous word that starts with word characters
	func! s:next_word(backward)
		let flags = 'We' . (a:backward ? 'b' :'')
		for _ in range(1, v:count1)
			call searchpos('\v(\W|^)\w', flags)
		endfor
	endf

	" jump after given characters without leaving insert mode
	inoremap <silent> <c-f> <c-r>=_jump_after("\\v[])}>\"']")<cr>

	func! _jump_after(pattern)
		return search(a:pattern, 'Wce') ? "\<right>" : ''
	endf

" SEARCH AND SUBSTITUTE
" ---------------------------------------------------------------------------

	aug _hlsearch
		au!
		if exists("##CmdlineEnter")
			au CmdlineEnter [/\?] set hlsearch
			au CmdlineLeave [/\?] set nohlsearch
		end
	aug END

	" use <tab> and <s-tab> instead of <c-g> and <c-t>
	cnoremap <expr> <tab> getcmdtype() =~ '[?/]' ? '<c-g>' : feedkeys('<tab>', 'int')[1]
	cnoremap <expr> <s-tab> getcmdtype() =~ '[?/]' ? '<c-t>' : feedkeys('<s-tab>', 'int')[1]

	noremap <c-b> ?
	noremap <c-f> /

	" toggle highlighting of the last search pattern
	nnoremap <silent> <c-h> :set hlsearch!<bar>set hlsearch?<cr>

	" Toggle search for current word or selected text without moving the cursor
	nnoremap <silent> S :call <sid>search(0)<cr>
	vnoremap <silent> S :<c-u>call <sid>search(1)<cr>

	fun! s:search(visual)
		if a:visual && line("'<") != line("'>")
			return
		end
		if a:visual
			let selection = getline('.')[col("'<")-1:col("'>")-1]
			let pattern = '\V' . escape(selection, '/\')
		else
			 let pattern = '\<' . expand('<cword>') . '\>'
		end
		if @/ == pattern
			let @/ = ''
			set nohlsearch
		else
			let @/ = pattern
			set hlsearch
		end
	endf

" YANK FEEDBACK
" ----------------------------------------------------------------------------

	aug _yankhl
		au!
		if exists("##TextYankPost") && has('timers')
			au TextYankPost * call <sid>yankhl()
		end
	aug END

	func! s:yankhl()
		if v:event.operator != 'y' || v:event.regname == '*'
			return
		end
		let lines = v:event.regcontents
		if len(lines) > &lines*2
			return
		end
		call map(lines, {-> escape(v:val, '\\')})
		if !empty(lines) && empty(lines[-1])
			let lines[-1] = '\n'
		end
		let pattern = printf('\V\%%%dl\%%%dc%s', line("'["), col("'["), join(lines, '\n'))
		let id = matchadd("Yank", pattern, -1)
		call timer_start(300, {-> call('matchdelete', [id])})
	endf

" MACROS
" ----------------------------------------------------------------------------

	vnoremap @ :norm! @

	nnoremap Q @q
	vnoremap <silent> Q :norm! @q<cr>

	" edit register q
	nnoremap <silent> gQ :<c-r><c-r>='let @q = '.string(getreg('q'))<cr><c-f><left>:res 1<cr>

" TAGS
" ----------------------------------------------------------------------------

	set tags=
	let g:tags_common = ['tags']

	aug _tags
		au!
		au FileType * if &ft != 'taglist' | call <sid>set_tagfiles() | end
		au User UpdateTagfiles call <sid>set_tagfiles()
	aug END

	" The order of tags file will determine in what position Taglist will display
	" them. Prefix them with a number followed by a dot to enforce an ordering:
	" ie. results from 0.project will always be displayed on top.
	" To ignore a tag file, prefix its name with an underscore.
	func! s:set_tagfiles()
		let local_tags = glob('.tags/'.&filetype.'/[^_]*', 1, 1)
		let global_tags = glob($XDG_DATA_HOME.'/tags/'.&filetype.'/[^_]*', 1, 1)
		let tagfiles = g:tags_common + local_tags + global_tags
		call setbufvar('%', '&tags', join(tagfiles, ','))
	endf

" PROJECT
" ----------------------------------------------------------------------------

	let g:root_markers = ['.gitignore', 'node_modules']

	aug _project_util
		au!
		au VimEnter * sil! CdRoot
	aug END

	" Find project root
	func! s:find_root(path)
		if empty(a:path) || a:path == '/'
			return ''
		end
		let files = glob(a:path.'/.*', 1, 1) + glob(a:path.'/*', 1, 1)
		let pattern = '\V\^\(' . join(get(g:, 'root_markers', []), '\|') . '\)\$'
		if match(map(files, "fnamemodify(v:val, ':t')"), pattern) >= 0
			return a:path
		end
		return s:find_root(fnamemodify(a:path, ':h'))
	endf

	" Cd into the current project root
	func! s:cd_into_root(bang)
		let path = s:find_root(expand('%:p:h'))
		if !empty(path)
			let cd = empty(a:bang) ? 'cd' : 'lcd'
			exec cd fnameescape(path)
			pwd
		end
	endf

	func! s:cd_into_bufdir(bang)
		let cd = empty(a:bang) ? 'cd' : 'lcd'
		exec cd fnameescape(expand('%:p:h'))
		pwd
	endf

	command! -bang -nargs=0 CdHere call <sid>cd_into_bufdir(<q-bang>)
	command! -bang -nargs=0 CdRoot call <sid>cd_into_root(<q-bang>)

	nnoremap gz :CdHere<cr>
	nnoremap gZ :CdRoot<cr>

" TRAILINGS
" ----------------------------------------------------------------------------

	aug _strip
		au!

		au BufWritePre * call <sid>strip_trailing_lines()
		au BufWritePre * call <sid>strip_trailing_spaces()

		au BufEnter,BufNewFile * let b:strip_spaces = 1
		au BufEnter,BufNewFile *.py let b:strip_lines = 1

	aug END

	func! s:strip_trailing_spaces()
		if &ft != 'diff' && get(g:, 'strip_spaces', 1) && get(b:, 'strip_spaces', 0)
			call _s('\v\s+$', '', 'e')
		end
	endf

	func! s:strip_trailing_lines()
		if &ft != 'diff' && get(g:, 'strip_lines', 1) && get(b:, 'strip_lines', 0)
			call _s('\v($\n\s*)+%$', '', '')
		end
	endf

" MISC
" ----------------------------------------------------------------------------

	aug _misc
		au!

		au BufWritePost *vimrc source $MYVIMRC
		au BufWritePost */colors/* nested exec 'colorscheme' g:colors_name

		au CmdWinEnter * set ft=
		au CmdWinEnter * noremap <buffer> <c-j> <cr>
		au CmdWinEnter * noremap <buffer> q <c-w>c
		au CmdWinEnter * setl nonumber norelativenumber

		" Keep clipboard content
		au VimLeave * call system("xclip -sel clip -i", getreg('+'))

		" Keep the help window to the bottom when there are multiple splits
		au BufWinEnter * if &ft == 'help' | wincmd J | end
		au BufWinEnter * if &ft == 'help' | nnoremap <silent> <buffer> q <c-w>c | end

		" Show cursorline only for a short amount of time
		au CursorHold,CursorHoldI * if &ft !~ '\v^(qf|explorer|buffers|finder|bookmarks|marks|taglist|plugs|search)$' | set nocul | end

		" Filetype fixes
		au BufNewFile,BufRead */Xresources.d/* set ft=xdefaults
		au BufNewFile,BufRead *.rasi set ft=css

		au BufReadPost * if &key != '' | setl noudf noswf nowb nobk nostmp secure hi=0 vi= | end
		au BufNewFile,BufReadPre /tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*,*/shm/* setl secure nostmp nowb nobk noswf hi=0 vi=
		au BufWritePre /tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*,*/shm/* setl noudf

	aug END

	" Execute the :s command without messing jumps or cursor
	func! _s(pattern, string, flags)
		let view = winsaveview()
		sil! exec 'keepj' 'keepp' '%s/'.a:pattern.'/'.a:string.'/'.a:flags
		call winrestview(view)
	endf

	" Open url in browser
	nnoremap <silent> gh :call <sid>open_url(0)<cr>
	vnoremap <silent> gh :call <sid>open_url(1)<cr>

	func! s:open_url(visual)
		if a:visual
			let url = ''
			if line("'<") == line("'>")
				let url = getline('.')[col("'<")-1:col("'>")-1]
			end
		else
			let url = expand('<cWORD>')
			let url = substitute(url, '\v(^\W+|\W+$)', '', 'g')
		end
		if empty(url)
			return
		end
		call system('firefox ' . shellescape(url))
		if !v:shell_error
			call system('i3-msg "[class="Firefox"] focus"')
		end
	endf

	" Clear undo history (:h clear-undo)
	command! -nargs=0 ClearUndo call <sid>clear_undo()

	func! s:clear_undo()
		let modified_save = &modified
		let undolevels_save = &undolevels
		let line_save = getline('.')
		set undolevels=-1
		exec "norm! a \<bs>\<esc>"
		call setline('.', line_save)
		let &undolevels = undolevels_save
		let &modified = modified_save
	endf

	" Edit filetype plugin
	command! -nargs=? -complete=filetype FtEdit call <sid>ft_edit(<q-args>)

	func! s:ft_edit(ft)
		let ft = empty(a:ft) ? &ft : a:ft
		call finder#find($HOME . '/.dotfiles', 'ftplugin.*'.ft.'\.vim$')
	endf

	command! -nargs=0 Vimrc edit $MYVIMRC
	command! -nargs=0 ColorEdit  exec 'e' $VIMHOME.'/colors/' . g:colors_name . '.vim'

	" Save the current buffer as sudo
	command! -nargs=0 WriteSudo exec 'write !sudo tee % > /dev/null'

	" Returns the syntax group under the cursor
	func! _cursyn()
		return synIDattr(synIDtrans(synID(line('.'), col('.'), 0)), 'name')
	endf

	cnoremap <c-n> <down>
	cnoremap <c-p> <up>

	inoremap <c-c> <c-]><esc>

	vnoremap C c

	noremap gj J
	noremap gk K

	nnoremap <silent> gow :set wrap!<bar>set wrap?<cr>
	nnoremap <silent> gon :set number!<bar>set number?<cr>
	nnoremap <silent> goz :let &scrolloff = abs(&scrolloff - 999)<bar>set scrolloff?<cr>

	iabbrev teh the
	iabbrev wiht with
	iabbrev lenght length
	iabbrev retrun return

" Command aliases
" ----------------------------------------------------------------------------

	let g:aliases = {
		\ 'find': 'Find', 'grep': 'Grep', 'greb': 'Greb', 'vim': 'Vim', 'vimb': 'Vimb',
		\ 'cdr': 'CdRoot', 'cdh': 'CdHere', 'ws': 'WriteSudo', 'vimrc': 'Vimrc',
		\ 'search': 'Search', 'sea': 'Search', 'tag': 'Tag',
	\ }

	cnoremap <cr> <c-]><c-\>e<sid>expand_aliases()<cr><cr>
	cnoremap <c-j> <c-]><c-\>e<sid>expand_aliases()<cr><cr>

	func! s:expand_aliases()
		if getcmdtype() == ':'
			let cmd = matchstr(getcmdline(), '\v\w+')
			return substitute(getcmdline(), '\v\w+', get(g:aliases, cmd, cmd), '')
		end
		return getcmdline()
	endf

" Search
" ----------------------------------------------------------------------------

	nnoremap gs :Search<space>
	nnoremap gr :Search<cr>
	nnoremap <silent> gS :Search \<<c-r><c-w>\><cr>

" Buffers
" ----------------------------------------------------------------------------

	nnoremap <silent> gl :Buffers<cr>
	nnoremap <silent> gL :Buffers!<cr>

" Finder
" ----------------------------------------------------------------------------

	nnoremap gp :Find<space>

" Marks
" ----------------------------------------------------------------------------

	nnoremap <silent> m, :call marks#view()<cr>
	nnoremap <silent> m. :call marks#set_auto(1)<cr>
	nnoremap <silent> m: :call marks#set_auto(0)<cr>

" Bookmarks
" ----------------------------------------------------------------------------

	nnoremap <silent> gm, :call bookmarks#view()<cr>
	nnoremap <silent> gm' :call bookmarks#jump(getchar())<cr>
	nnoremap <silent> gmm :call bookmarks#set(getchar(), expand('%:p'))<cr>
	nnoremap <silent> gmd :call bookmarks#set(getchar(), expand('%:p:h'))<cr>

" Taglist
" ----------------------------------------------------------------------------

	nnoremap <silent> <c-]> :Tag <c-r><c-w><cr>

" Ctags
" ----------------------------------------------------------------------------

	let g:ctags = {
		\ 'python_options': '--exclude=venv',
		\ 'javascript_options': '--exclude=node_modules',
	\ }

" Spotter
" ----------------------------------------------------------------------------

	let g:spotter_banned_filetypes = {
		\ 'html':1, 'jinja':1, 'htmldjango':1, "json":1,
	   \ 'text':1, 'markdown':1, 'notes':1,
	\ }

	let g:spotter_banned_syntax_elixir = {
		\ 'elixirDocString':1
	\ }

	let g:spotter_banned_words_javascript = {
		\ 'var':1, 'let':1, 'const':1, 'function':1, 'class':1
	\ }

" Ale
" ----------------------------------------------------------------------------

	highlight link AleError None
	highlight link AleWarning None
	highlight link AleErrorSign Exception
	highlight link AleWarningSign Repeat

	let g:ale_sign_error = 'x'
	let g:ale_sign_warning = '!'
	let g:ale_lint_on_text_changed = 'never'
	let g:ale_open_list = 0

" Explorer
" ----------------------------------------------------------------------------

	let g:explorer_filters = [{node -> node.filename() !~ '\v^(.git|node_modules|venv)$'}]

	" nnoremap <silent> gy :Explorer<cr>
	" nnoremap <silent> g. :exec 'Explorer' expand('%:p')<cr>
	" nnoremap <silent> g: :exec 'Explorer' getcwd()<cr>

" Ranger
" ----------------------------------------------------------------------------

	fun! s:ranger(target)
		let tmp = tempname()
		let cmd  = ['!ranger']
		let cmd += ['--choosefiles='.tmp]
		if filereadable(a:target)
			let cmd += ['--selectfile='.shellescape(a:target)]
		end
		if &columns < 150
			let cmd += ["--cmd='set column_ratios 1'"]
			let cmd += ["--cmd='set preview_files false'"]
			let cmd += ["--cmd='set preview_directories false'"]
			let cmd += ["--cmd='set collapse_preview true'"]
		end
		sil exec join(cmd)
		if v:shell_error
			echoerr "Command failed with error" v:shell_error.":" join(cmd)
		end
		if filereadable(tmp)
			let files = map(readfile(tmp), {i, v -> fnameescape(v)})
			if len(files) > 1
				exec 'argadd' join(files)
			end
			exec 'edit' files[0]
			call delete(tmp)
		end
		redraw!
	endf

	if executable('ranger')
		nnoremap <silent> g. :call <sid>ranger(expand('%:p'))<cr>
		nnoremap <silent> g: :call <sid>ranger(getcwd())<cr>
	end

" Ultisnips
" ----------------------------------------------------------------------------

	let g:UltiSnipsExpandTrigger = '<c-s>'
	let g:UltiSnipsJumpForwardTrigger = '<c-s>'
	let g:UltiSnipsJumpBackwardTrigger = '<c-b>'
	let g:UltiSnipsSnippetsDir = $VIMHOME . '/UltiSnips'

" GitGutter
" ----------------------------------------------------------------------------

	let g:gitgutter_enabled = 0

" Disable unused plugins
" ----------------------------------------------------------------------------

	let g:loaded_logiPat = 1
	let g:loaded_vimballPlugin = 1
	let g:loaded_getscriptPlugin = 1
	let g:loaded_2html_plugin = 1
	let g:loaded_netrwPlugin = 1
